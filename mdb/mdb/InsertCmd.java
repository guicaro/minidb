// Automatically generated code.  Edit at your own risk!
// Generated by bali2jak v2002.09.03.

package mdb;

import java.io.UnsupportedEncodingException;
import java.util.Map;
import java.util.Vector;

import util.DBAccess;
import util.GenericTuple;

import com.sleepycat.bind.EntryBinding;
import com.sleepycat.bind.serial.SerialBinding;
import com.sleepycat.bind.serial.StoredClassCatalog;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.CursorConfig;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Transaction;

public class InsertCmd extends Insert {

	final public static int ARG_LENGTH = 2;
	final public static int TOK_LENGTH = 6;
	private Transaction txn;

	public void execute() {
		
		DBAccess dbInstance = DBAccess.getInstance();	
		
		if(dbInstance.getEnvironment() == null )
		{
			System.out.println("ERROR: An environment has not been opened");
		}
		else
		{
				
		String relName = getRel_name().toString().trim().toLowerCase();
		Database metaDb = null;
		Database workDb = null;
		Map<String, Vector<String>> schemaMap =  dbInstance.getSchemaMap();
		
		// Get transaction from environment
		txn = dbInstance.getActiveTransaction();

		// Search the "metaTable" table for a record using the
		// table name specified in the query as the "key"
		String searchKey = relName;
		Vector<String> columnInfo = new Vector<String>();

		// Check if such an entry exists (table specified exists)
		if (schemaMap.containsKey(relName)) {
			
			columnInfo = (Vector) schemaMap.get(relName);
			Boolean typeError = false;
			AstCursor c = new AstCursor();
			Vector<String> insertInfo = new Vector<String>();
			int pos=1;

			// Traverse and store information on the literal list from the input query
			for (c.First(getLiteral_list()); c.More(); c.PlusPlus()) {
				
				if (c.node.className().equals("StrLit")
						|| c.node.className().equals("IntLit")) {
					
					// Get attribute value
					insertInfo.add(c.node.toString().trim());
					
				if (!columnInfo.elementAt(pos).toLowerCase().startsWith(
								c.node.className().toLowerCase().substring(0, 3))) 
							typeError = true;
					
				        // Point to next column in schema
						pos+=3;
				}
			}

			// Check for error in the number of attributes specified
			if( (columnInfo.size() / 3) != insertInfo.size())
			{
				System.out
						.println("ERROR: Incorrect number of attributes, expecting: "
								+ columnInfo.size() / 3 + ".");

			} else {

				// Compare the attribute types specified in query against
				// the types stored in "metaTable" which contain the table
				// schema information.

				if (typeError) {
					System.out.print("ERROR: Incorrect type of attributes, expecting: ");
							for(int r=1; r<columnInfo.size(); r+=3)
							{
								System.out.print(columnInfo.elementAt(r).substring(0, 3) + " ");
								
							}
					System.out.println("");
				} else {

					// No errors to this point, is is safe to open the table
					workDb = dbInstance.getDbHandle(relName);

					// Set the "key" as the first attribute specified
					// and the "data" including all attributes
					String insertKey = insertInfo.elementAt(0);
					GenericTuple tupleData = new GenericTuple();
					tupleData.setTuple(insertInfo);

					// Insert record
					OperationStatus insertStatus = dbInstance.store(insertKey, tupleData, workDb, txn);
					
					if(insertStatus == OperationStatus.SUCCESS)
					{
						System.out.println("Successfully inserted record");						
					}
					else if (insertStatus == OperationStatus.KEYEXIST)
					{
						System.out.println("ERROR: Unable to insert record, key already exists");

					}
					else
					{
						System.out.println("ERROR: Unable to insert record");
					}

				}

			}

		} else {
			// Print error message
			System.out.println("ERROR: Table " + relName + " does not exist");
		}

		}
		
		super.execute();
		
	}

	public AstToken getINSERT() {

		return (AstToken) tok[0];
	}

	public AstToken getINTO() {

		return (AstToken) tok[1];
	}

	public AstToken getLP() {

		return (AstToken) tok[3];
	}

	public Literal_list getLiteral_list() {

		return (Literal_list) arg[1];
	}

	public AstToken getRP() {

		return (AstToken) tok[4];
	}

	public Rel_name getRel_name() {

		return (Rel_name) arg[0];
	}

	public AstToken getSEMI() {

		return (AstToken) tok[5];
	}

	public AstToken getVALUES() {

		return (AstToken) tok[2];
	}

	public boolean[] printorder() {

		return new boolean[] { true, true, false, true, true, false, true, true };
	}

	public InsertCmd setParms(AstToken tok0, AstToken tok1, Rel_name arg0,
			AstToken tok2, AstToken tok3, Literal_list arg1, AstToken tok4,
			AstToken tok5) {

		arg = new AstNode[ARG_LENGTH];
		tok = new AstTokenInterface[TOK_LENGTH];

		tok[0] = tok0; /* INSERT */
		tok[1] = tok1; /* INTO */
		arg[0] = arg0; /* Rel_name */
		tok[2] = tok2; /* VALUES */
		tok[3] = tok3; /* LP */
		arg[1] = arg1; /* Literal_list */
		tok[4] = tok4; /* RP */
		tok[5] = tok5; /* SEMI */

		InitChildren();
		return (InsertCmd) this;
	}

}

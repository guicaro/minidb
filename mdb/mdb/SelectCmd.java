// Automatically generated code.  Edit at your own risk!
// Generated by bali2jak v2002.09.03.

package mdb;
import java.util.*;

import util.DBAccess;
import query.*;

public class SelectCmd extends Select {

	final public static int ARG_LENGTH = 3;
	final public static int TOK_LENGTH = 3;
	private DBAccess dbInstance = DBAccess.getInstance();
	private Map<String, Vector<String>> schemaMap =  dbInstance.getSchemaMap();
	private Map<Integer, QueryPlan> queryMap =  new HashMap();
	private QueryPlan masterPlan = null;
	private int crossProdRows = 0;
		
	public void execute() {
		
		// We need an active environment to run operations
		if (dbInstance.getEnvironment() == null) {
			System.out.println("ERROR: An environment has not been opened");
		} else {
			
			QueryPlan initQP = new QueryPlan(1);
			Vector<Vector<Vector<String>>> scannedRels= new Vector<Vector<Vector<String>>>();			
			
			long startTime = System.currentTimeMillis();
			int queryMapSize;
			int minPlanId = 1;
			int minCost= 9999;
			
			// 1 - Parse query and error check
			if(!parseQuery(initQP))
			{
				return;
			}
			
			// 2 - Enumerate plans
			Vector<Relation> rels = initQP.getRelations();
			
			if(rels.size() == 1 )
			{
			    queryMap.put(initQP.getId(), initQP);
			}
			else if(rels.size() == 2 )
			{
				// Create new plan from initial plan
				QueryPlan plan1 = new QueryPlan(2, rels, initQP.getJoinPreds(), initQP.getProjectedAttr());

				// Change order of scan
				swapRelations(plan1.getRelations(), 0);

				queryMap.put(initQP.getId(), initQP);
				queryMap.put(plan1.getId(), plan1);
				
			}
			else if(rels.size() == 3 )
			{
				int count = rels.size()+3;
				int swapPos = 0; 
				
				queryMap.put(initQP.getId(), initQP);
				
				while(count>1)
				{
					// Create new plan from initial plan
					QueryPlan plan = new QueryPlan(count, rels, initQP.getJoinPreds(), initQP.getProjectedAttr());

					// Change order of scan
					swapRelations(plan.getRelations(), swapPos);
					
					queryMap.put(plan.getId(), plan);
					rels = plan.getRelations();
					
					count --;
					
					//Switch for swaps
					if(swapPos == 0)
						swapPos = 1;
					else
						swapPos=0;
				}			
				
			}
			else
			{
				masterPlan = initQP;
			}
			
			// Update the number of plans
			queryMapSize = queryMap.size();
			
			// 3 - Compute cost & choose minimum cost plan
			computeCostForPlans();
			
			Iterator keyValuePairs = queryMap.entrySet().iterator();
			for (int a = 0; a < queryMapSize; a++)
			{
			  Map.Entry entry = (Map.Entry) keyValuePairs.next();
			  QueryPlan plan = (QueryPlan)entry.getValue();			 
			  
			  if(plan.getCost()<minCost)
			  {
				  minPlanId=plan.getId();
				  minCost=plan.getCost();
			  }
				  			  
			}
			
			masterPlan = queryMap.get(minPlanId);
			
			// 4 - Set the scan method
			setScanType();
						
			// 5 - Execute masterPlan
			// 5.1 - Scan
			for(int numRels=0; numRels<masterPlan.getRelations().size(); numRels++)
			{
				// Get first relation, check if index scan or normal scan
				if(masterPlan.getRelations().elementAt(numRels).getScanType() ==1)
				{
					//Create IXSCAN object
					IndexScan ixScan = new IndexScan();
					scannedRels.addElement(ixScan.process(masterPlan.getRelations().elementAt(numRels)));
				}
				else
				{
					//normal scan object
					NormalScan nScan = new NormalScan();
					scannedRels.addElement(nScan.process(masterPlan.getRelations().elementAt(numRels)));
				}
				
			}			
			
			// 5.2 - Join
			if(masterPlan.getRelations().size() > 1)
			{
				for(int count=1; count<scannedRels.size(); count++)
				{
					// Insert at 0 and remove 1;
					scannedRels.add(0, nestedLoopJoin(scannedRels.elementAt(0), scannedRels.elementAt(count), count));
					scannedRels.removeElementAt(1);
					
				}
			}
					
			// 5.3 - Project
			printResult(scannedRels.elementAt(0), startTime);
			
			// 5.4 - Cleanup
			scannedRels.clear();
			scannedRels = null;
			
		}

		super.execute();
	}

	public AstToken getFROM() {

		return (AstToken) tok[1];
	}

	public Proj_list getProj_list() {

		return (Proj_list) arg[0];
	}

	public Rel_list getRel_list() {

		return (Rel_list) arg[1];
	}

	public AstToken getSELECT() {

		return (AstToken) tok[0];
	}

	public AstToken getSEMI() {

		return (AstToken) tok[2];
	}

	public WherePred getWherePred() {

		AstNode node = arg[2].arg[0];
		return (node != null) ? (WherePred) node : null;
	}

	public boolean[] printorder() {

		return new boolean[] { true, false, true, false, false, true };
	}

	public SelectCmd setParms(AstToken tok0, Proj_list arg0, AstToken tok1,
			Rel_list arg1, AstOptNode arg2, AstToken tok2) {

		arg = new AstNode[ARG_LENGTH];
		tok = new AstTokenInterface[TOK_LENGTH];

		tok[0] = tok0; /* SELECT */
		arg[0] = arg0; /* Proj_list */
		tok[1] = tok1; /* FROM */
		arg[1] = arg1; /* Rel_list */
		arg[2] = arg2; /* [WherePred] */
		tok[2] = tok2; /* SEMI */

		InitChildren();
		return (SelectCmd) this;
	}
	
	private boolean parseQuery(QueryPlan qp){
		
		Vector<Relation> rels = qp.getRelations();
		AstCursor cur = new AstCursor();
		Vector<String> columnInfo = null;
		
		// Extract FROM
		for (cur.FirstElement(getRel_list()); cur.MoreElement(); cur.NextElement() ) {
			
			if(!schemaMap.containsKey(cur.node.toString().trim()))
			{
				System.out.println("ERROR: Table(s) in FROM clause do not exist");
				return false;
			}
		   	qp.addRelation(cur.node.toString().trim());
		}	
		
		// Extract SELECT
		if(getProj_list().className().equals("All"))
		{
		   qp.addProjectedAttr("*");
		}
		else
		{
			for (cur.First(getProj_list().arg[0]), cur.PlusPlus(); cur.More() ; cur.PlusPlus())
			{
				if(!cur.node.className().equals("RelDotField") && rels.size()>1 )
				{
					System.out.println("ERROR: Please specify projected attributes as: \"Relation.Attribute\"");
					return false;
				}
				
				if(cur.node.className().equals("RelDotField"))
				{
					qp.addProjectedAttr(cur.node.arg[0].toString().trim().concat(".").concat(cur.node.arg[1].toString().trim()));
				}
				else
				{
					// Case for single relation, we need to add Relation suffix.
					qp.addProjectedAttr(rels.elementAt(0).getRelationName().concat(".").concat(cur.node.toString().trim()));
				}
				cur.Sibling();
			}
		}
		
		// Extract WHERE
		if(getWherePred() != null)
		{
			for (cur.First(getWherePred()), cur.PlusPlus(), cur.PlusPlus(); cur.More() ; cur.PlusPlus())
			{
				if(cur.node.className().equals("JoinClause"))
				{
					if(!cur.node.arg[0].className().equals("RelDotField"))
					{
						System.out.println("ERROR: Please specify join predicates as \"Relation.Attribute\"");
						return false;
					}
					else
					{
						// Concat relation name and field name (left Attr)
						qp.addJoinPred(cur.node.arg[0].arg[0].toString().trim().concat(".").concat(
								cur.node.arg[0].arg[1].toString().trim()),
								cur.node.arg[1].arg[0].toString().trim().concat(".").concat(
								cur.node.arg[1].arg[1].toString().trim()));
					}

				}
				else
				{
					if( rels.size() == 1 )
					{
						// Add suffix of relation for single attribute (internal mode)
						rels.elementAt(0).addLocalPred(rels.elementAt(0).getRelationName().concat(".").concat(cur.node.arg[0].toString().trim()),
								cur.node.arg[1].toString().trim(),
								cur.node.arg[2].toString().trim());
					}	
					else
					{
						if(!cur.node.arg[0].className().equals("RelDotField"))
						{	
							System.out.println("ERROR: For Joins, please specify local predicates as \"Relation.Attribute\"");
							return false;
						}
						
		
						String attr = cur.node.arg[0].arg[0].toString().trim().concat(".").concat(
								cur.node.arg[0].arg[1].toString().trim());
						String oper = cur.node.arg[1].toString().trim();
						String value = cur.node.arg[2].toString().trim();
						
						for(int relPosition=0; relPosition<rels.size(); relPosition++)
						{
							if (attr.substring(0,attr.indexOf(".")).equals(rels.elementAt(relPosition).getRelationName()))
							{
								rels.elementAt(relPosition).addLocalPred(attr, oper, value);
								break;
							}
								
						}
					
			        }	
					
				}
				cur.Sibling();
			}
		}
		
		// More error checking
		
        for(int pos=0; pos <rels.size(); pos++)
        {
        	String relName = qp.getRelations().elementAt(pos).getRelationName();
        	columnInfo =  new Vector<String>();
        	columnInfo = (Vector) schemaMap.get(relName);
        	boolean found = false;
        	
        	Vector <LocalPred> preds = qp.getRelations().elementAt(pos).getLocalPreds();
        	
        	
        	for(int predPos=0; predPos<preds.size(); predPos++)
        	{
        		for(int colPos=0; colPos<columnInfo.size(); colPos+=3)
        		{
        	  		if(preds.elementAt(predPos).getAttribute().equals(columnInfo.elementAt(colPos)))
        	  		{
        	  			found = true;
        	  			break;
        	  		}
        	  		else
        	  		{
        	  			found=false;
        	  		}
        		}
        		
            	if(!found)
            	{
            		System.out.println("ERROR: Attribute(s) in local predicate(s) do not exist");
            		return false;
            	}
      
        	}
			
        }
		
		return true;
	}
	
	private Vector <Vector<String>> nestedLoopJoin(Vector<Vector<String>> outer, Vector<Vector<String>> inner,
			int count) {
		
		Vector <Relation> relations = masterPlan.getRelations();
		Vector <JoinPred> joinPreds = masterPlan.getJoinPreds();
		Vector <Vector<String>> tempJoin= new Vector<Vector<String>>();
		String outerJoinAttr = null;
		String innerJoinAttr = null;
		String outerRelation;
		String innerRelation;
		int attrPosOuter = -1;
		int attrPosInner = -1;
		boolean foundPred = false;
		boolean crossProd = false;
		
		// Get names of relations to join
		if(count == 1)
		{
			outerRelation = relations.elementAt(0).getRelationName();
			innerRelation = relations.elementAt(1).getRelationName();
		
		}
		else
		{
			// Outer relation name is concatenation of previously joined
			// relations.
			outerRelation = "##".concat(relations.elementAt(0).getRelationName());
			
			for(int x=1; x<count; x++)
			{
				outerRelation = outerRelation.concat(relations.elementAt(x).getRelationName());
			}
			
			innerRelation = relations.elementAt(count).getRelationName();
			
		}
		

		// CROSS PRODUCTS, no JOIN PREDS
		if(joinPreds.size() == 0)
		{
			crossProd = true;
			foundPred=true;
		}
		else
		{
			// Find which join predicate to use
			for(int predPos=0; predPos<joinPreds.size(); predPos ++)
			{
				// Check if left and right contain relations to be joined.
				outerJoinAttr = joinPreds.elementAt(predPos).getLeftAttr();
				innerJoinAttr = joinPreds.elementAt(predPos).getRightAttr();
				
				if(count == 1)
				{
					if(outerJoinAttr.startsWith(outerRelation))
					{
						if(innerJoinAttr.startsWith(innerRelation))
						{
							foundPred=true;
						}
					}
					else if(outerJoinAttr.startsWith(innerRelation))
					{
						if(innerJoinAttr.startsWith(outerRelation))
						{
							String temp = outerJoinAttr;
							outerJoinAttr = innerJoinAttr;
							innerJoinAttr = temp;
							foundPred=true;
						}
					}
					else
					{
						continue;
					}			
				}
				else
				{
					// Find a join predicate that contains the inner relation
					// in either the left or right attribute of predicate
					if(outerJoinAttr.startsWith(innerRelation))
					{
						String temp = outerJoinAttr;
						outerJoinAttr = innerJoinAttr;
						innerJoinAttr = temp;
						foundPred=true;
					}
					else if (innerJoinAttr.startsWith(innerRelation))
					{
						foundPred=true;
					}
					else{
						continue;
					}
				}
				
				if(foundPred)
				{
					joinPreds.removeElementAt(predPos);
					break;
				}
				else
				{
				}	
				
			}
			
			if(foundPred)
			{
			attrPosOuter = findPosition(outerRelation, outerJoinAttr);
			attrPosInner = findPosition(innerRelation, innerJoinAttr);
			}
		}

		// Create entry in meta Table for this temporary join.
		addEntryToMemMetaDb(outerRelation, innerRelation, count);
		
		// Perform Nested Loop Join for qualifying tuples
		if(crossProd || !foundPred)
		{	
			if( relations.size() == (count+1))
			{		
				for (int outCount=0; outCount<outer.size(); outCount++)
				{	
					for (int inCount=0; inCount<inner.size(); inCount++)
					{
						printCrossProd(outer.elementAt(outCount), inner.elementAt(inCount), outCount, inCount);
						crossProdRows++;
					}
				}
			}
			else
			{
				for (int outCount=0; outCount<outer.size(); outCount++)
				{	
					for (int inCount=0; inCount<inner.size(); inCount++)
					{
						Vector <String> tempRec = new Vector<String>();
						tempRec.addAll(outer.elementAt(outCount));
						tempRec.addAll(inner.elementAt(inCount));
							 
						tempJoin.addElement(tempRec);
					}
				}
			}			
				
		}
		else
		{
			for (int outCount=0; outCount<outer.size(); outCount++)
			{				
				for (int inCount=0; inCount<inner.size(); inCount++)
				{
					if(outer.elementAt(outCount).elementAt(attrPosOuter).equals(
							inner.elementAt(inCount).elementAt(attrPosInner)))
					{
						Vector <String> tempRec = new Vector<String>();
						tempRec.addAll(outer.elementAt(outCount));
					    tempRec.addAll(inner.elementAt(inCount));
					  				    
					    tempJoin.addElement(tempRec);
					}
					else
					{
						continue;
					}
				}
				
			}
		}
		
		return tempJoin;
		
	}

	private void printCrossProd(Vector<String> outer,
			Vector<String> inner, int outCount, int inCount) {

		int numOfRelations = masterPlan.getRelations().size();
		Vector <String> projAttrs = masterPlan.getProjectedAttr();
		Vector <String> columnInfo = null;
		int recCount=-1;
		String nameResultRel = "##";
		
		if(numOfRelations == 1)
		{
			nameResultRel = masterPlan.getRelations().elementAt(0).getRelationName();
		}
		else
		{
			nameResultRel = nameResultRel.concat(masterPlan.getRelations().elementAt(0).getRelationName());
			
			for(int y=1; y<numOfRelations; y++)
			{
				nameResultRel = nameResultRel.concat(masterPlan.getRelations().elementAt(y).getRelationName());
			}			
		}
		
		columnInfo = schemaMap.get(nameResultRel);
		
		
		if(outCount == 0 && inCount ==0)
		{
			
			StringBuilder sb = new StringBuilder();
			Formatter formatter = new Formatter(sb, Locale.US);
			
			// Print headers
			if(projAttrs.elementAt(0).equals("*"))
			{
				sb.append("\n");
			    sb.append("|");
				
				for(int z=0; z<columnInfo.size(); z+=3)
				{
					 formatter.format("%1$-35s %2$1s", columnInfo.elementAt(z), "|");
				}
				
				sb.append("\n");
			}
			else
			{
				sb.append("\n");
				sb.append("|");
				
				// Print Headers
				for(int x=0; x<projAttrs.size(); x++)
				{
					formatter.format("%1$-35s %2$1s", projAttrs.elementAt(x), "|");
				}				
				sb.append("\n");
			}
			
		}

		// Print record
		Vector <String> temp = new Vector<String>();
		temp.addAll(outer);
		temp.addAll(inner);
		
		StringBuilder sb = new StringBuilder();
		Formatter formatter = new Formatter(sb, Locale.US);
				
		if(projAttrs.elementAt(0).equals("*"))
		{
			sb.append("|");
			
			// Print all attributes in records
			for(recCount=0; recCount<temp.size(); recCount++)
			{				
				formatter.format("%1$-35s %2$1s", temp.elementAt(recCount), "|");
			}
			sb.append("\n");	
			
		}
		else
		{
			sb.append("|");
			
			for(int projCount=0; projCount<projAttrs.size(); projCount++)
			{
				int projPos = findPosition(nameResultRel, projAttrs.elementAt(projCount));
				formatter.format("%1$-35s %2$1s", temp.elementAt(projPos), "|");
			}
			sb.append("\n");	
			
		}

		System.out.print(sb);
		sb = null;
				
	}

	private void addEntryToMemMetaDb(String rel1, String rel2, int count) {
		
		Vector<String> schemaInfo1 = schemaMap.get(rel1);
		Vector<String> schemaInfo2 = schemaMap.get(rel2);
		Vector<String> tempSchema = new Vector<String>();
		
		// Combine schemas from both tables
		// Format: attr | type | indexed | attr | type | indexed | 
		
		tempSchema.addAll(schemaInfo1);
		tempSchema.addAll(schemaInfo2);
		if (count == 1)
			schemaMap.put("##".concat(rel1).concat(rel2), tempSchema);
		else
			schemaMap.put((rel1).concat(rel2), tempSchema);
	}

	private void printResult(Vector<Vector<String>> resultRel, long beginTime) {
		
		int numOfRelations = masterPlan.getRelations().size();
		Vector <String> projAttrs = masterPlan.getProjectedAttr();
		Vector <String> columnInfo = null;
		int recCount=-1;
		int projPos;
		String nameResultRel = "##";
		
		if(crossProdRows > 1)
		{
			System.out.print("(" + crossProdRows + ") Record(s) found in: ");
		}
		else
		{
			if(numOfRelations == 1)
			{
				nameResultRel = masterPlan.getRelations().elementAt(0).getRelationName();
			}
			else
			{
				nameResultRel = nameResultRel.concat(masterPlan.getRelations().elementAt(0).getRelationName());
				
				for(int y=1; y<numOfRelations; y++)
				{
					nameResultRel = nameResultRel.concat(masterPlan.getRelations().elementAt(y).getRelationName());
				}			
			}
			
			columnInfo = schemaMap.get(nameResultRel);
				
			// Print
			if(projAttrs.size() == 1 && projAttrs.elementAt(0).equals("*"))
			{
				StringBuilder sb = new StringBuilder();
				Formatter formatter = new Formatter(sb, Locale.US);

				sb.append("\n");
			    sb.append("|");
				
				// Print Headers
				for(int z=0; z<columnInfo.size(); z+=3)
				{
					 formatter.format("%1$-35s %2$1s", columnInfo.elementAt(z), "|");
				}
				
				sb.append("\n");
				
				// Print all attributes in records
				for(recCount=0; recCount<resultRel.size(); recCount++)
				{
					sb.append("|");
					
					for(int attrPtr=0; attrPtr<columnInfo.size()/3; attrPtr++)
					{
						formatter.format("%1$-35s %2$1s", resultRel.elementAt(recCount).elementAt(attrPtr), "|");
					}
					sb.append("\n");	
				}
				
				System.out.print(sb);
				
			}
			else
			{
				StringBuilder sb = new StringBuilder();
				Formatter formatter = new Formatter(sb, Locale.US);
				
				sb.append("\n");
				sb.append("|");
				
				// Print Headers
				for(int x=0; x<projAttrs.size(); x++)
				{
					formatter.format("%1$-35s %2$1s", projAttrs.elementAt(x), "|");
				}				
				sb.append("\n");
				
				// Print selected attributes in records in order.
				for(recCount=0; recCount<resultRel.size(); recCount++)
				{		
					sb.append("|");
					
					for(int projCount=0; projCount<projAttrs.size(); projCount++)
					{
						projPos = findPosition(nameResultRel, projAttrs.elementAt(projCount));
						formatter.format("%1$-35s %2$1s", resultRel.elementAt(recCount).elementAt(projPos), "|");
					}
					sb.append("\n");			
				}	
				
				System.out.print(sb);
			}
		}
	
		long endTime = System.currentTimeMillis();
	    float seconds = (endTime - beginTime) / 1000F;
	        		        
        if(recCount == 0)
        {
        	  System.out.print("(0) Records found in: " + Float.toString(seconds) + " seconds." );

        }
        else if (crossProdRows >1)
        {
        	System.out.print( Float.toString(seconds) + " seconds." );
        }
        else
        {
        	  System.out.print("(" + recCount + ") Record(s) found in: " + Float.toString(seconds) + " seconds." );
        }
        
          // Check if we did an index scan
  	      for (int relCount=0; relCount<numOfRelations; relCount++)
  	      {
  	    	  if(masterPlan.getRelations().elementAt(relCount).getScanType() == 1)
  	    		  System.out.print("\n Using index on:" + masterPlan.getRelations().elementAt(relCount).getRelationName());
  	    		  
  	      }
		
	}
	
	private int findPosition(String relName, String attrName) {

		Vector <String> columnInfo = schemaMap.get(relName);

		for (int pos=0; pos<columnInfo.size(); pos+=3)
		{
			if(columnInfo.elementAt(pos).equals(attrName))
			   return pos/3;
		}
		return -1;
	}

	private void swapRelations(Vector<Relation> relations, int offset) {
				
		Collections.swap(relations, 0+offset, 1+offset);
	}

	private void computeCostForPlans() {
				
		// Compute penalties for each relation in queryPlan with ID = 0;
		 HashMap<String, Integer> relPenalties = new HashMap<String, Integer>();
		 Vector <Relation> rels = queryMap.get(1).getRelations();
		 Vector <JoinPred> joinPreds = queryMap.get(1).getJoinPreds();
		 int queryMapSize = queryMap.size();
		 int penalty =0;
		 int cost =0;
		 
		 if(rels.size() == 1)
		 {
			 return;
		 }
		 
		 // Get penalty values for each relation
		 for(int relCount=0; relCount<rels.size(); relCount++)
		 {
			 penalty = 0;
			 Vector <LocalPred> preds = rels.elementAt(relCount).getLocalPreds();
			 
			 // No predicates in relation to filter
			 if(preds.size() == 0)
				 penalty += 1;
			 
			 // If predicates exist, none have an index.
			 if(preds.size() != 0)
			 {
				 boolean indexedAttr= false;
				 
				 for(int x=0; x<preds.size(); x++)
				 {
					if(dbInstance.isIndexed(preds.elementAt(x).getAttribute()))
					{
						indexedAttr = true;
					}
				 }
				 
				 if(!indexedAttr)
					 penalty += 1;
			 }
			 
			 // No join predicates  for this relation (case for Cross Products)
			 boolean relInJoins = false;
			 
			 for(int y = 0; y<joinPreds.size(); y++)
			 {
				 String leftAttr = joinPreds.elementAt(y).getLeftAttr();
				 String rightAttr = joinPreds.elementAt(y).getLeftAttr();
				 String relName = rels.elementAt(relCount).getRelationName();
				 
				 if(leftAttr.startsWith(relName) || rightAttr.startsWith(relName))
					 relInJoins = true;	
			 
			 }
			 
			 if(!relInJoins)
				 penalty +=1;

			  relPenalties.put(rels.elementAt(relCount).getRelationName(), penalty);
			 
		 }
		
		// Use penalty values with the join order of relations
			Iterator keyValuePairs = queryMap.entrySet().iterator();
			for (int mapCount = 0; mapCount < queryMapSize; mapCount++)
			{
			  cost=0;	
				
			  Map.Entry entry = (Map.Entry) keyValuePairs.next();
			  QueryPlan plan = (QueryPlan)entry.getValue();
			  
			  // Penalty case for no explicit join predicate with next column to be scanned
			  int orderPenalty=0;
				 
			  	 for(int y = 0; y<joinPreds.size(); y++)
				 {
					 String leftAttr = joinPreds.elementAt(y).getLeftAttr();
					 String rightAttr = joinPreds.elementAt(y).getRightAttr();
					 String outerName = plan.getRelations().elementAt(0).getRelationName();
					 String innerName = plan.getRelations().elementAt(1).getRelationName();
					 boolean foundPred = false;
					 
					 if(leftAttr.startsWith(outerName))
						{
							if(rightAttr.startsWith(innerName))
							{
								foundPred=true;
								break;
							}
						}
						else if(leftAttr.startsWith(innerName))
						{
							if(rightAttr.startsWith(outerName))
							{
								foundPred=true;
								break;
							}
						}
						else
						{
							continue;
						}	
					 
					 if(!foundPred)
						 orderPenalty+=1;
					 
				 }
				
			  int positionMult = rels.size();
			  
			  for(int relCount=0; relCount<rels.size(); relCount++)
			  {
				  if(relCount == 0)
				  {
					  cost += (positionMult) * ( orderPenalty + relPenalties.get(plan.getRelations().elementAt(relCount).getRelationName()));
				  }
				  else
				  {
					  cost += (positionMult) * relPenalties.get(plan.getRelations().elementAt(relCount).getRelationName()); 
				  }
				  positionMult--;
			  }	
			  
			  
			  plan.setCost(cost);
			}
	}
	
	private void setScanType() {
		
		Vector <Relation> rels = masterPlan.getRelations();
	
		for(int relCount=0; relCount<rels.size(); relCount++)
		{
			Vector <LocalPred> preds = rels.elementAt(relCount).getLocalPreds();
			
			// Check all the local predicates in each relation and see if any is indexed
			// in order to do an index scan.
			for(int predCount=0; predCount<preds.size(); predCount++)
			{
				if(preds.elementAt(predCount).getOperator().equals("=") && 
				   dbInstance.isIndexed(preds.elementAt(predCount).getAttribute()))
				{
					rels.elementAt(relCount).setScanType(1);
					rels.elementAt(relCount).setScanAttrPosition(predCount);
					break;
				}
				                      
			}
			
		}
		
	}
	
}
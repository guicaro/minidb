// Automatically generated code.  Edit at your own risk!
// Generated by bali2jak v2002.09.03.

package mdb;

import java.io.*;
import java.util.*;

import util.DBAccess;
import util.GenericTuple;

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.Environment;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Transaction;

public class RelDecl extends Decl_rel {

	final public static int ARG_LENGTH = 2;
	final public static int TOK_LENGTH = 5;
	private Transaction txn;

	public void execute() {

		DBAccess dbInstance = DBAccess.getInstance();
		
		// We need an active environment to run operations
		if(dbInstance.getEnvironment() == null )
		{
			System.out.println("ERROR: An environment has not been opened");
		}
		else
		{
		
		String relName = getRel_name().toString().trim().toLowerCase();
		Database metaDb = null;
		boolean duplicateNames = false;
		Map schemaMap =  dbInstance.getSchemaMap();
		
		// Get transaction from environment
		txn = dbInstance.getActiveTransaction();
		
		// Traverse AST to get schema information
		AstCursor c = new AstCursor();
		Vector<String> fieldInfo = new Vector<String>(50);

		// Get attribute names and types from field declaration list
		int colNumber = 0;
		
		for (c.First(getFld_decl_list()); c.More(); c.PlusPlus()) {
			if (c.node.className().equals("FieldName")) {
				
				// Add attribute name as Relation.Field
				fieldInfo.add(relName.concat(".").concat(c.node.toString().trim().toLowerCase()));
				
				c.PlusPlus();

				// Attribute type
				fieldInfo.add(c.node.className());
				
				// Indexed flag
				if(colNumber==0)
					fieldInfo.add("1");
				else
					fieldInfo.add("0");
				
				colNumber++;
			}
		}

		// Set the "key" and "data" portion to store in BDB
		String aKey = relName;
		GenericTuple tupleData = new GenericTuple();
		tupleData.setTuple(fieldInfo);

        if(schemaMap.containsKey(relName))
        {	
			System.out.println("ERROR: Table " + relName + " already exists");
		}
		else
		{
			// Table does exist. Now, traverse the query's field declaration list
			// to see if there are duplicate attribute names specified
			for(int x=0; x<fieldInfo.size(); x+=2)
			{			
				for(int y=0; y<fieldInfo.size(); y+=3)
				{
					if(x==y)
						continue;
					
					if(fieldInfo.elementAt(x).equalsIgnoreCase(fieldInfo.elementAt(y)))
					{
						duplicateNames = true;
						break;
					}
				}
			}

			if(duplicateNames)
			{
				System.out.println("ERROR: Unable to create table with duplicate attribute names");
			}
			else
			{
				// No errors in query to this point
				// Store an entry to the "metaTable" table which stores schema information
				// for created tables.				

				metaDb = dbInstance.getDbHandle("metaTable");
				
				if(dbInstance.store(aKey, tupleData, metaDb, txn) == OperationStatus.SUCCESS)
				{
					dbInstance.getDbHandle(relName);
					System.out.println("Successfully created table: " + relName );
					
					schemaMap.put(relName, fieldInfo);
					
				}
				else
				{
					System.out.println("ERROR: Unable to create table");
				}
				
			}
			
		}
		
		}
			
		super.execute();
		
		
	}

	public AstToken getCREATE() {

		return (AstToken) tok[0];
	}

	public Fld_decl_list getFld_decl_list() {

		return (Fld_decl_list) arg[1];
	}

	public AstToken getLP() {

		return (AstToken) tok[2];
	}

	public AstToken getRP() {

		return (AstToken) tok[3];
	}

	public Rel_name getRel_name() {

		return (Rel_name) arg[0];
	}

	public AstToken getSEMI() {

		return (AstToken) tok[4];
	}

	public AstToken getTABLE() {

		return (AstToken) tok[1];
	}

	public boolean[] printorder() {

		return new boolean[] { true, true, false, true, false, true, true };
	}

	public RelDecl setParms(AstToken tok0, AstToken tok1, Rel_name arg0,
			AstToken tok2, Fld_decl_list arg1, AstToken tok3, AstToken tok4) {

		arg = new AstNode[ARG_LENGTH];
		tok = new AstTokenInterface[TOK_LENGTH];

		tok[0] = tok0; /* CREATE */
		tok[1] = tok1; /* TABLE */
		arg[0] = arg0; /* Rel_name */
		tok[2] = tok2; /* LP */
		arg[1] = arg1; /* Fld_decl_list */
		tok[3] = tok3; /* RP */
		tok[4] = tok4; /* SEMI */

		InitChildren();
		return (RelDecl) this;
	}

}

// Automatically generated code.  Edit at your own risk!
// Generated by bali2jak v2002.09.03.

package mdb;

import Jakarta.util.*;
import java.io.*;
import java.util.*;

import util.DBAccess;
import util.GenericTuple;

import com.sleepycat.bind.EntryBinding;
import com.sleepycat.bind.serial.SerialBinding;
import com.sleepycat.bind.serial.StoredClassCatalog;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Transaction;

public class IndxDecl extends Decl_ind {

	final public static int ARG_LENGTH = 1;
	final public static int TOK_LENGTH = 2;
	private Transaction txn;

	public void execute() {

		DBAccess dbInstance = DBAccess.getInstance();

		if (dbInstance.getEnvironment() == null) {
			System.out.println("ERROR: An environment has not been opened");
		} else {

			String relName = getRel_dot_field().arg[0].toString().trim()
					.toLowerCase();
			String column = getRel_dot_field().arg[1].toString().trim()
					.toLowerCase();
			Map<String, Vector<String>> schemaMap = dbInstance.getSchemaMap();
			
			txn = dbInstance.getActiveTransaction();

			if (!schemaMap.containsKey(relName)) {
				System.out.println("ERROR: Table " + relName
						+ " does not exist");
				return;
			}
			
			//Check all attributes in relation until we find the column specified
			Vector<String> columnInfo = new Vector<String>();				
			columnInfo = (Vector) schemaMap.get(relName);
			
			for(int pos=0; pos<columnInfo.size(); pos+=3)
			{
				if(!relName.concat(".").concat(column).equals(columnInfo.elementAt(pos)))
				{
					continue;
				}
				
				// Position of index flag
				if(columnInfo.elementAt(pos+2).equals("1"))
				{
					System.out.println("ERROR: Column: " + column + " is already indexed." );
				}
				
				if(dbInstance.createSecondaryDb(relName, column, (pos/3)))
				{
					//Print success message
					System.out.println("Successfully created index");
				}
				
				//Update memory metaDB, since column is now indexed
				
				// Position of indexed flag for attribute that was indexed
				columnInfo.set(pos+2, "1");
				schemaMap.put(relName, columnInfo);
				
				//Also update normal metadata table
				Cursor cursor = null;
				Database metaDb = dbInstance.getDbHandle("metaTable");
				GenericTuple retTuple = new GenericTuple();
				
				try {
				
				cursor = metaDb.openCursor(txn, null);
				
				// Create the "data" binding
				StoredClassCatalog myClassCatalog = dbInstance.getClassCatalog();
				EntryBinding dataBinding = new SerialBinding(myClassCatalog,
						GenericTuple.class);
				
				// Get the DatabaseEntry objects that the cursor will use.
				DatabaseEntry searchKey = new DatabaseEntry(relName.getBytes("UTF-8"));
				DatabaseEntry foundData = new DatabaseEntry();

					cursor.getSearchKey(searchKey, foundData, LockMode.DEFAULT);
					cursor.delete();
					cursor.close();
					
				} catch (DatabaseException e) {
					System.out.println("ERROR: While updating metadata table on creation of Index");
				} catch (UnsupportedEncodingException e) {
					
				}
				
				// Insert updated record
				retTuple.setTuple(columnInfo);
				
				OperationStatus insertStatus = dbInstance
				.store(relName, retTuple, metaDb, txn);
				
			}
			
		}
		super.execute();
	}

	public AstToken getINDEX() {

		return (AstToken) tok[0];
	}

	public Rel_dot_field getRel_dot_field() {

		return (Rel_dot_field) arg[0];
	}

	public AstToken getSEMI() {

		return (AstToken) tok[1];
	}

	public boolean[] printorder() {

		return new boolean[] { true, false, true };
	}

	public IndxDecl setParms(AstToken tok0, Rel_dot_field arg0, AstToken tok1) {

		arg = new AstNode[ARG_LENGTH];
		tok = new AstTokenInterface[TOK_LENGTH];

		tok[0] = tok0; /* INDEX */
		arg[0] = arg0; /* Rel_dot_field */
		tok[1] = tok1; /* SEMI */

		InitChildren();
		return (IndxDecl) this;
	}

}
